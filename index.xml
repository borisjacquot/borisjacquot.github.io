<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Boris Jacquot</title>
        <link>https://borisjacquot.github.io/</link>
        <description>Recent content on Boris Jacquot</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 25 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://borisjacquot.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Stack HashiCorp</title>
        <link>https://borisjacquot.github.io/p/stack-hashicorp/</link>
        <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://borisjacquot.github.io/p/stack-hashicorp/</guid>
        <description>&lt;img src="https://borisjacquot.github.io/p/stack-hashicorp/hashicorp.jpg" alt="Featured image of post Stack HashiCorp" /&gt;&lt;h1 id=&#34;stack-hashicorp&#34;&gt;Stack HashiCorp&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;HashiCorp est une entreprise de software base ç San Francisco en Californie. Cette entreprise propose une suite de logiciels open-source orientés service. Deux d&amp;rsquo;entre eux sont &lt;code&gt;Consul&lt;/code&gt; et &lt;code&gt;Nomad&lt;/code&gt;.
&lt;a class=&#34;link&#34; href=&#34;https://www.hashicorp.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&amp;raquo; plus d&amp;rsquo;info&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;consul&#34;&gt;Consul&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>La haute disponibilité</title>
        <link>https://borisjacquot.github.io/p/la-haute-disponibilit%C3%A9/</link>
        <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://borisjacquot.github.io/p/la-haute-disponibilit%C3%A9/</guid>
        <description>&lt;img src="https://borisjacquot.github.io/p/la-haute-disponibilit%C3%A9/haute-disponibilite.jpg" alt="Featured image of post La haute disponibilité" /&gt;&lt;h1 id=&#34;la-haute-disponibilité&#34;&gt;La haute disponibilité&lt;/h1&gt;
&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;Le but d&amp;rsquo;une HA est de rendre un service disponible quand un serveur est surchargé. Dans notre cas nous prendrons l&amp;rsquo;exemple d&amp;rsquo;un site web static dans un premier temps.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TODO: schéma&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Nous avons notre site qui tourne sur un serveur apache, jusque ici tout va bien. Admettons que le serveur soit surchargé, comment assurer la disponibilité du site ?&lt;/p&gt;
&lt;p&gt;-&amp;gt; on va dans un premier temps multiplier le nombre de serveurs qui font tourner le site.&lt;/p&gt;
&lt;p&gt;Mais comment faire quand tous les serveurs sont surchargés ?&lt;/p&gt;
&lt;h2 id=&#34;les-load-balencers-lb&#34;&gt;Les load balencers (LB)&lt;/h2&gt;
&lt;p&gt;Il existe plusieures techno de LB :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;nginx&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HAProxy&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;traefic&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;A quoi ça sert ?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Un LB va distribuer le traffic vers les serveurs. Si un serveur tombe en panne, il va le retirer de son &lt;em&gt;pool&lt;/em&gt; et l&amp;rsquo;accès au service sera toujours possible.&lt;/p&gt;
&lt;p&gt;Cependant, un seul LB crée un &lt;strong&gt;SPOF&lt;/strong&gt; (point de défaillance unique), c&amp;rsquo;est à dire que si il tombe, tout tombe (comme DC3 lol). Pour éviter ceci, on a la possibilité de mettre plusieurs LB. Mais comment choisir quel LB il faut utiliser ?&lt;/p&gt;
&lt;p&gt;-&amp;gt; On utilise le système de &lt;code&gt;Quorum&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On va mettre en place un nombre impair de LB afin qu&amp;rsquo;il n&amp;rsquo;y ait pas de &lt;em&gt;&amp;ldquo;vote nul&amp;rdquo;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;On va les mettre en place grâce à deux techno : &lt;code&gt;corosync&lt;/code&gt; et &lt;code&gt;pacemaker&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Corosync&lt;/em&gt; va créer un cluster où les LB discutent en paires. Un LB sera désigné comme étant le &lt;em&gt;maître&lt;/em&gt; et les autres des &lt;em&gt;esclaves&lt;/em&gt;. Si le maître vient à mourir, corosync va transmettre l&amp;rsquo;information aux autres LB et ces derniers vont élire un nouveau &lt;em&gt;maître&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Pacemaker&lt;/em&gt; partage la ressource (ici l&amp;rsquo;IP). La ressource doit toujours être sur le &lt;em&gt;maître&lt;/em&gt;. Quand le &lt;em&gt;maître&lt;/em&gt; décède, Pacemaker va informer Corosync qu&amp;rsquo;il n&amp;rsquo;est plus apte à être &lt;em&gt;maître&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;passage-en-dynamique&#34;&gt;Passage en dynamique&lt;/h3&gt;
&lt;p&gt;Si maintenant notre site passe en dynamique, avec une BDD par exemple, si nous mettons simplement une BDD liée à l&amp;rsquo;API, nous nous confrontons à un SPOF à ce niveau.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;schema&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;La solution est donc de mettre une fois de plus des LB, ainsi que plusieurs BDD.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Les LB fonctionnent de la même manière.&lt;/li&gt;
&lt;li&gt;Les BDD fonctionnent en maître-esclave + une n+1 ième sert de backup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;backbone&#34;&gt;Backbone&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;todo + schema&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;les-cdn&#34;&gt;Les CDN&lt;/h2&gt;
&lt;p&gt;Pour être ncore plus efficace, on peut mettre un CDN avant les LB. Un CDN permet de mettre en cache des réponses à des requêtes pour éviter de passer par tout le processus vu précédemment afin de perdre le moins de temps possible.
Une des technos utilisées est &lt;em&gt;Varnish&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;schema maybe&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Cloudflare&lt;/strong&gt; sert, entre autre, de cache.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>Les conteneurs</title>
        <link>https://borisjacquot.github.io/p/les-conteneurs/</link>
        <pubDate>Sat, 22 May 2021 00:00:00 +0000</pubDate>
        
        <guid>https://borisjacquot.github.io/p/les-conteneurs/</guid>
        <description>&lt;img src="https://borisjacquot.github.io/p/les-conteneurs/conteneurs.jpg" alt="Featured image of post Les conteneurs" /&gt;&lt;h1 id=&#34;les-conteneurs&#34;&gt;Les conteneurs&lt;/h1&gt;
&lt;h2 id=&#34;random-things&#34;&gt;Random things&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; et &lt;code&gt;pstree&lt;/code&gt; permettent de voir la liste des processus actifs sur la machine (package &lt;code&gt;procps&lt;/code&gt;).
Au démarrage le processus &lt;code&gt;1&lt;/code&gt; sera toujours &lt;code&gt;/init&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dans le cas d&amp;rsquo;une machine virtuelle, l&amp;rsquo;information va être traitée une première fois par la VM, puis est réinterprêtée par le noyau.
(On peut skip ceci et gagner du temps avec &lt;code&gt;VT-x&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Un conteneur =/= une VM&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;les-namespaces&#34;&gt;Les Namespaces&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Processus&lt;/strong&gt; : Les prcessus dans le NS vont être isolés des autres. À l&amp;rsquo;intérieur du NS, le premier processus aura donc l&amp;rsquo;ID &lt;code&gt;1&lt;/code&gt; (cf /init). Du point de vue du noyau, ce processus aura un autre ID qui lui est propre. Il est impossible, à l&amp;rsquo;intérieur du NS, de voir les autres processus de la machine. Cependant, l&amp;rsquo;inverse est vrai. &lt;em&gt;(cf pstree dans chaque)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Réseau&lt;/strong&gt; : On peut créer une interface virtuelle qui sera alors connectée (ou non) à une interface de la machine (via un bridge par exemple).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;User / group&lt;/strong&gt; : Les utilisateurs dans un NS peuvent avoir le même ID que ceux de la machine. Il peut donc y avoir des faille (par exemple : avoir l&amp;rsquo;ID 0 dans le NS donne les droits du l&amp;rsquo;ID 0 de la machine = root). Pour y remédier, on utilise &lt;em&gt;l&amp;rsquo;UID shifting&lt;/em&gt; =&amp;gt; càd on va dire que tous les UID seront +4000 (par exemple) par rapport à ceux de la machine, donc plus sécurisant.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Un ensemble de NS crée un conteneur. On le crée grâce à un &lt;code&gt;clone()&lt;/code&gt; &lt;em&gt;(fork ou thread)&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker va simplifier la création de conteneurs en s&amp;rsquo;occupant de créer tous les NS. On peut choisir ce qu&amp;rsquo;on met dedans grâce à une image.&lt;/p&gt;
&lt;p&gt;Par exemple : pour un site web static qui tourne sous nginx, on va procéder de la sorte :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On va créer un fichier &lt;code&gt;Dockerfile&lt;/code&gt; avec toutes les instructions pour installer le conteneur (comment build l&amp;rsquo;image). Dans notre cas on pourra écrire dedans :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# on dl l&#39;image que l&#39;on souhaite =&amp;gt; ici nginx qui tourne sur alpine (une distro avec le minimum légal pour que ce soit léger)
FROM nginx:alpine

# on lance des commandes pour le build
RUN apt update &amp;amp;&amp;amp; apt install [...]

# on copie notre index (par exemple)
COPY ./docker/base/fpm/resources/index.html /usr/local/nginx/html

# on copie notre script qui sera le proc 1 selon ce qu&#39;on veut
COPY ./docker/base/fpm/resources/index.html /entrypoint

# on défini un user pour exécuter les choses =&amp;gt; on donne peu de droits pour éviter les failles
USER www-data

# on choisi l&#39;espace de travail
WORKDIR &amp;quot;/application&amp;quot;

# on choisi notre point d&#39;entrée (donc le proc 0)
ENTRYPOINT [&amp;quot;/entrypoint&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Ensuite on peut lancer :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ docker build -t my-image:v0.1 .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;et hop!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>

[{"content":"La haute disponibilité Intro Le but d\u0026rsquo;une HA est de rendre un service disponible quand un serveur est surchargé. Dans notre cas nous prendrons l\u0026rsquo;exemple d\u0026rsquo;un site web static dans un premier temps.\nTODO: schéma\nNous avons notre site qui tourne sur un serveur apache, jusque ici tout va bien. Admettons que le serveur soit surchargé, comment assurer la disponibilité du site ?\n-\u0026gt; on va dans un premier temps multiplier le nombre de serveurs qui font tourner le site.\nMais comment faire quand tous les serveurs sont surchargés ?\nLes load balencers (LB) Il existe plusieures techno de LB :\n Apache nginx HAProxy traefic  A quoi ça sert ?\nUn LB va distribuer le traffic vers les serveurs. Si un serveur tombe en panne, il va le retirer de son pool et l\u0026rsquo;accès au service sera toujours possible.\nCependant, un seul LB crée un SPOF (point de défaillance unique), c\u0026rsquo;est à dire que si il tombe, tout tombe (comme DC3 lol). Pour éviter ceci, on a la possibilité de mettre plusieurs LB. Mais comment choisir quel LB il faut utiliser ?\n-\u0026gt; On utilise le système de Quorum\n On va mettre en place un nombre impair de LB afin qu\u0026rsquo;il n\u0026rsquo;y ait pas de \u0026ldquo;vote nul\u0026rdquo;\n On va les mettre en place grâce à deux techno : corosync et pacemaker\n  Corosync va créer un cluster où les LB discutent en paires. Un LB sera désigné comme étant le maître et les autres des esclaves. Si le maître vient à mourir, corosync va transmettre l\u0026rsquo;information aux autres LB et ces derniers vont élire un nouveau maître\n  Pacemaker partage la ressource (ici l\u0026rsquo;IP). La ressource doit toujours être sur le maître. Quand le maître décède, Pacemaker va informer Corosync qu\u0026rsquo;il n\u0026rsquo;est plus apte à être maître.\n  Passage en dynamique Si maintenant notre site passe en dynamique, avec une BDD par exemple, si nous mettons simplement une BDD liée à l\u0026rsquo;API, nous nous confrontons à un SPOF à ce niveau.\nschema\nLa solution est donc de mettre une fois de plus des LB, ainsi que plusieurs BDD.\n  Les LB fonctionnent de la même manière. Les BDD fonctionnent en maître-esclave + une n+1 ième sert de backup.   Backbone todo + schema\nLes CDN Pour être ncore plus efficace, on peut mettre un CDN avant les LB. Un CDN permet de mettre en cache des réponses à des requêtes pour éviter de passer par tout le processus vu précédemment afin de perdre le moins de temps possible. Une des technos utilisées est Varnish\nschema maybe\n Cloudflare sert, entre autre, de cache.\n ","date":"2021-05-22T00:00:00Z","image":"https://borisjacquot.github.io/p/la-haute-disponibilit%C3%A9/haute-disponibilite_hu3d03a01dcc18bc5be0e67db3d8d209a6_2329900_120x120_fill_q75_box_smart1.jpg","permalink":"https://borisjacquot.github.io/p/la-haute-disponibilit%C3%A9/","title":"La haute disponibilité"},{"content":"Les conteneurs Random things ps et pstree permettent de voir la liste des processus actifs sur la machine (package procps). Au démarrage le processus 1 sera toujours /init\n Dans le cas d\u0026rsquo;une machine virtuelle, l\u0026rsquo;information va être traitée une première fois par la VM, puis est réinterprêtée par le noyau. (On peut skip ceci et gagner du temps avec VT-x)\n Un conteneur =/= une VM\nLes Namespaces   Processus : Les prcessus dans le NS vont être isolés des autres. À l\u0026rsquo;intérieur du NS, le premier processus aura donc l\u0026rsquo;ID 1 (cf /init). Du point de vue du noyau, ce processus aura un autre ID qui lui est propre. Il est impossible, à l\u0026rsquo;intérieur du NS, de voir les autres processus de la machine. Cependant, l\u0026rsquo;inverse est vrai. (cf pstree dans chaque)\n  Réseau : On peut créer une interface virtuelle qui sera alors connectée (ou non) à une interface de la machine (via un bridge par exemple).\n  User / group : Les utilisateurs dans un NS peuvent avoir le même ID que ceux de la machine. Il peut donc y avoir des faille (par exemple : avoir l\u0026rsquo;ID 0 dans le NS donne les droits du l\u0026rsquo;ID 0 de la machine = root). Pour y remédier, on utilise l\u0026rsquo;UID shifting =\u0026gt; càd on va dire que tous les UID seront +4000 (par exemple) par rapport à ceux de la machine, donc plus sécurisant.\n  Docker  Un ensemble de NS crée un conteneur. On le crée grâce à un clone() (fork ou thread).\n Docker va simplifier la création de conteneurs en s\u0026rsquo;occupant de créer tous les NS. On peut choisir ce qu\u0026rsquo;on met dedans grâce à une image.\nPar exemple : pour un site web static qui tourne sous nginx, on va procéder de la sorte :\n On va créer un fichier Dockerfile avec toutes les instructions pour installer le conteneur (comment build l\u0026rsquo;image). Dans notre cas on pourra écrire dedans :  # on dl l'image que l'on souhaite =\u0026gt; ici nginx qui tourne sur alpine (une distro avec le minimum légal pour que ce soit léger) FROM nginx:alpine # on lance des commandes pour le build RUN apt update \u0026amp;\u0026amp; apt install [...] # on copie notre index (par exemple) COPY ./docker/base/fpm/resources/index.html /usr/local/nginx/html # on copie notre script qui sera le proc 1 selon ce qu'on veut COPY ./docker/base/fpm/resources/index.html /entrypoint # on défini un user pour exécuter les choses =\u0026gt; on donne peu de droits pour éviter les failles USER www-data # on choisi l'espace de travail WORKDIR \u0026quot;/application\u0026quot; # on choisi notre point d'entrée (donc le proc 0) ENTRYPOINT [\u0026quot;/entrypoint\u0026quot;]  Ensuite on peut lancer :  $ docker build -t my-image:v0.1 . et hop!\n","date":"2021-05-22T00:00:00Z","image":"https://borisjacquot.github.io/p/les-conteneurs/conteneurs_hu3d03a01dcc18bc5be0e67db3d8d209a6_3399148_120x120_fill_q75_box_smart1.jpg","permalink":"https://borisjacquot.github.io/p/les-conteneurs/","title":"Les conteneurs"}]